// Using basic TypeScript types for message structure
import { LeisureActivity, ActivityType } from '../types';

// Helper function to get Groq API key from environment variables
const getGroqApiKey = (): string => {
  return process.env.NEXT_PUBLIC_GROQ_API_KEY || '';
};

// Helper function to make Groq API calls
// Defining message structure with a more flexible role type
type ChatMessage = {
  role: string;
  content: string;
};

async function callGroqApi(messages: ChatMessage[], model: string, options: any = {}) {
  const apiKey = getGroqApiKey();
  
  if (!apiKey) {
    throw new Error('Groq API key not found');
  }

  const defaultOptions = {
    max_tokens: 250,
    temperature: 0.7,
  };

  const requestOptions = {
    ...defaultOptions,
    ...options,
  };

  const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model,
      messages,
      ...requestOptions,
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Groq API error: ${error}`);
  }

  return await response.json();
}

/**
 * Enhance activity descriptions with Groq's LLM
 * @param basicDescription The original activity description
 * @param activityType The type of activity
 * @returns An enhanced description generated by Groq's LLM
 */
export async function enhanceActivityDescription(
  basicDescription: string,
  activityType: ActivityType
): Promise<string> {
  // If API key is not set, return the original description
  if (!getGroqApiKey()) {
    console.warn('Groq API key not found. Using original description.');
    return basicDescription;
  }

  try {
    const messages = [
      {
        role: 'system',
        content: 'You are a travel and leisure expert. Enhance the given activity description to make it more engaging, informative and exciting without being verbose. Maintain the original tone and key information, but add helpful details travelers would appreciate.'
      },
      {
        role: 'user',
        content: `Enhance this ${activityType} activity description (keep it under 200 characters): ${basicDescription}`
      }
    ];

    const response = await callGroqApi(messages, 'llama3-8b-8192', {
      max_tokens: 250,
      temperature: 0.7
    });

    return response.choices[0].message.content || basicDescription;
  } catch (error) {
    console.error('Error enhancing description with Groq:', error);
    return basicDescription; // Return original on error
  }
}

/**
 * Generate personalized activity recommendations based on user preferences
 * @param activities Available activities
 * @param userPreferences User preferences including favorite types and tags
 * @returns Ranked list of recommended activities
 */
export async function getPersonalizedRecommendations(
  activities: LeisureActivity[],
  userPreferences: {
    favoriteTypes: ActivityType[];
    favoriteTags: string[];
    location?: { lat: number; lng: number };
  }
): Promise<LeisureActivity[]> {
  // If API key is not set, return activities sorted by rating
  if (!getGroqApiKey()) {
    console.warn('Groq API key not found. Using basic recommendation logic.');
    return activities.sort((a, b) => (b.rating || 0) - (a.rating || 0));
  }

  try {
    // Create a context object to pass to Groq
    const context = {
      favoriteTypes: userPreferences.favoriteTypes,
      favoriteTags: userPreferences.favoriteTags,
      activities: activities.map(a => ({
        id: a.id,
        title: a.title,
        type: a.type,
        tags: a.tags,
        rating: a.rating || 0
      }))
    };

    const messages = [
      {
        role: 'system',
        content: 'You are a personalization expert helping to rank leisure activities for a user. Return a JSON array of activity IDs in order of recommendation relevance based on the user\'s preferences.'
      },
      {
        role: 'user',
        content: `Given these user preferences: ${JSON.stringify(userPreferences)} 
                 And these activities: ${JSON.stringify(context.activities)}
                 Return a JSON array of activity IDs in order of recommendation (most relevant first). Only include the IDs, not the full objects.`
      }
    ];

    const response = await callGroqApi(messages, 'llama3-8b-8192', {
      max_tokens: 500,
      temperature: 0.3
    });

    // Parse the ranked IDs from Groq's response
    const content = response.choices[0].message.content || '{"rankedIds": []}';
    const rankedIds = JSON.parse(content).rankedIds || [];

    // Sort the activities based on the ranked order
    const idToRank = new Map(rankedIds.map((id: string, index: number) => [id, index]));
    return activities.sort((a, b) => {
      const rankA = idToRank.has(a.id) ? (idToRank.get(a.id) as number) : Number.MAX_SAFE_INTEGER;
      const rankB = idToRank.has(b.id) ? (idToRank.get(b.id) as number) : Number.MAX_SAFE_INTEGER;
      return rankA - rankB;
    });
  } catch (error) {
    console.error('Error getting personalized recommendations:', error);
    // Fallback to simple rating-based sorting
    return activities.sort((a, b) => (b.rating || 0) - (a.rating || 0));
  }
}

/**
 * Process natural language search queries
 * @param query Natural language query from user
 * @returns Structured search filters
 */
export async function processNaturalLanguageQuery(query: string): Promise<{
  types?: ActivityType[];
  priceRange?: { min: number; max: number };
  tags?: string[];
}> {
  // Default filter structure
  const defaultFilters = {
    types: [] as ActivityType[],
    priceRange: { min: 0, max: 1000 },
    tags: [] as string[]
  };

  // If API key is not set, do basic keyword parsing
  if (!getGroqApiKey()) {
    console.warn('Groq API key not found. Using basic query parsing.');
    return defaultFilters;
  }

  try {
    const messages = [
      {
        role: 'system',
        content: 'You extract structured search parameters from natural language queries about leisure activities. Return a VALID JSON object with fields: types (array of activity types), priceRange (object with min and max), and tags (array of relevant tags). The response must be ONLY valid JSON with no additional text.'
      },
      {
        role: 'user',
        content: `Extract search filters from this query: "${query}"
          Valid activity types are: outdoor, indoor, cultural, entertainment, sports, culinary, educational, nightlife, wellness, other.
          Return ONLY a valid JSON object with these fields (if detected):
          {"types":["type1","type2"], "priceRange":{"min":0,"max":100}, "tags":["tag1","tag2"]}`
      }
    ];

    const response = await callGroqApi(messages, 'llama3-8b-8192', {
      max_tokens: 300,
      temperature: 0.2 // Lower temperature for more consistent output
    });

    // Extract only the JSON part from the response
    let content = response.choices[0].message.content || '{}';
    
    // Try to find JSON object in the response if it's wrapped in markdown or text
    try {
      // Check for JSON block in markdown
      const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      if (jsonMatch && jsonMatch[1]) {
        content = jsonMatch[1].trim();
      }
      
      // Sometimes LLMs add text before or after the JSON
      // Look for the outermost { } pair
      const firstBrace = content.indexOf('{');
      const lastBrace = content.lastIndexOf('}');
      
      if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        content = content.substring(firstBrace, lastBrace + 1);
      }
      
      const parsedFilters = JSON.parse(content);
      
      // Validate the parsed data structure
      return {
        ...defaultFilters,
        types: Array.isArray(parsedFilters.types) ? parsedFilters.types : defaultFilters.types,
        priceRange: (
          parsedFilters.priceRange && 
          typeof parsedFilters.priceRange === 'object' && 
          !isNaN(parsedFilters.priceRange.min) && 
          !isNaN(parsedFilters.priceRange.max)
        ) ? parsedFilters.priceRange : defaultFilters.priceRange,
        tags: Array.isArray(parsedFilters.tags) ? parsedFilters.tags : defaultFilters.tags
      };
    } catch (parseError) {
      console.error('Failed to parse JSON from Groq response:', parseError);
      console.log('Problematic content:', content);
      return defaultFilters;
    }
  } catch (error) {
    console.error('Error processing natural language query:', error);
    return defaultFilters;
  }
}
